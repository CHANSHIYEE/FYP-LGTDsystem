package shiyee_FYP.fullstack_backend.Service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import shiyee_FYP.fullstack_backend.model.ChinaCompany;
import shiyee_FYP.fullstack_backend.model.LocRelation;
import shiyee_FYP.fullstack_backend.model.Location;

import shiyee_FYP.fullstack_backend.repository.ChinaCompanyRepository;
import shiyee_FYP.fullstack_backend.repository.LocationRelationRepository;
import shiyee_FYP.fullstack_backend.repository.LocationRepository;

import java.util.*;
import java.util.stream.Collectors;

import org.springframework.transaction.annotation.Transactional;

@Service
public class VulnerabilityService {

    @Autowired
    private LocationRepository locationRepo;

    @Autowired
    private LocationRelationRepository relationRepo;

    @Autowired
    private ChinaCompanyRepository companyRepo;
    @Autowired
    private GraphService graphService; // 新增依赖

    // 节点类型权重配置
    private static final Map<Location.LocationType, Double> LOCATION_WEIGHTS = Map.of(
            Location.LocationType.RESEARCH, 0.8,
            Location.LocationType.WAREHOUSE, 0.6,
            Location.LocationType.FACTORY, 0.9,
            Location.LocationType.SUPPLIER, 0.85,
            Location.LocationType.PROTOTYPE, 0.75,
            Location.LocationType.DISTRIBUTION, 0.7,
            Location.LocationType.MANUFACTURER, 0.8,
            Location.LocationType.TESTING, 0.65
    );

    // 关系类型权重配置
    private static final Map<LocRelation.RelationType, Double> RELATION_WEIGHTS = Map.of(
            LocRelation.RelationType.SILICON_WAFER, 0.9,
            LocRelation.RelationType.SEMI_MATERIAL, 0.8,
            LocRelation.RelationType.TARGET_MATERIAL, 0.7,
            LocRelation.RelationType.PROTOTYPE_FLOW, 0.85,
            LocRelation.RelationType.PHOTONICS_FLOW, 0.8,
            LocRelation.RelationType.STORAGE_FLOW, 0.6,
            LocRelation.RelationType.PACKAGE_TEST, 0.75,
            LocRelation.RelationType.FINISHED_GOODS, 0.7,
            LocRelation.RelationType.JUST_IN_TIME, 0.9,
            LocRelation.RelationType.BACKUP_DELIVERY, 0.5
    );

    private static final double DEFAULT_WEIGHT = 0.5;


    /**
     * 全量计算（保证与单节点计算逻辑一致）
     */
    @Transactional
    public void calculateAllVulnerabilityScores() {
        List<Location> locations = locationRepo.findAll();
        List<LocRelation> relations = relationRepo.findAll();
        locations.forEach(loc -> {
            double score = calculateScore(
                    loc,
                    locations,
                    relations
            );
            loc.setVulnerabilityScore(score);
        });

        locationRepo.saveAll(locations);
    }

    @Transactional(readOnly = true)
    public double calculateSingleNodeScore(Integer locationId) {
        Location location = locationRepo.findById(locationId).orElseThrow();
        List<Location> allLocations = locationRepo.findAll();
        List<LocRelation> allRelations = relationRepo.findAll();
        return calculateScore(
                location,
                allLocations,
                allRelations

        );
    }

    private double calculateScore(Location location,
                                  List<Location> allLocations,
                                  List<LocRelation> allRelations
            ) {
        // 1. 业务语义权重
        double semanticScore = calculateSemanticScore(location, allRelations);
        // 2. 不可替代性
        double uniquenessScore = calculateUniquenessScore(location, allLocations, allRelations);
        // 3. 综合计算
//        return 0.3 * semanticScore + 0.2 * companyScore + 0.5 * uniquenessScore;
        return 0.5 * semanticScore  + 0.5 * uniquenessScore;
    }

    public double calculateSemanticScore(Location loc, List<LocRelation> relations) {
        double typeWeight = LOCATION_WEIGHTS.getOrDefault(loc.getType(), 0.5);

        double relationWeight = relations.stream()
                .filter(r -> r.getSource().getId().equals(loc.getId()) ||
                        r.getTarget().getId().equals(loc.getId()))
                .mapToDouble(r -> RELATION_WEIGHTS.getOrDefault(r.getRelationType(), 0.5))
                .average()
                .orElse(0.5);

        return (typeWeight * 0.6) + (relationWeight * 0.4);
    }

    public double calculateUniquenessScore(Location loc,
                                           List<Location> allLocations,
                                           List<LocRelation> allRelations) {
        // 获取当前节点的所有下游节点
        Set<Integer> downstreamIds = allRelations.stream()
                .filter(r -> r.getSource().getId().equals(loc.getId()))
                .map(r -> r.getTarget().getId())
                .collect(Collectors.toSet());

        if (downstreamIds.isEmpty()) return 0.3;

        // 计算有多少下游节点是唯一供应的
        long uniqueDestinations = downstreamIds.stream()
                .filter(downstreamId -> allRelations.stream()
                        .filter(r -> r.getTarget().getId().equals(downstreamId))
                        .count() == 1)
                .count();

        return (double) uniqueDestinations / downstreamIds.size();
    }
}